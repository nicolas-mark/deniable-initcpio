#!/usr/bin/ash

run_hook() {
    modprobe -a -q dm-crypt >/dev/null 2>&1
    modprobe -a -q loop >/dev/null 2>&1
    [ "${quiet}" = "y" ] && CSQUIET=">/dev/null"

    # Get the loop device key file, if specified.
    cloopkey="/crypto_keyfile.bin"
    cloopname="crypto_loop"

    # Get encrypted loop device containing headers and keyfile
    cloopfile="/crypto_loop.bin"
    if [ -n "$cryptloop" ]; then
        IFS=: read cloopdev clarg1 clarg2 <<EOF
$cryptloop
EOF
        if [ "$cloopdev" = "rootfs" ]; then
            cloopfile=$clarg1
        elif resolved=$(resolve_device "${cloopdev}" ${rootdelay}); then
            case ${clarg1} in
                *[!0-9]*)
                    # Use a file on the device
                    # clarg1 not numeric: clarg1=filesystem, clarg2=path
                    mkdir /cloop
                    mount -r -t "$clarg1" "$resolved" /cloop
                    dd if="/cloop/$clarg2" of="$cloopfile" >/dev/null 2>&1
                    umount /cloop
                    ;;
                *)
                    # Read raw data from the block device
                    # clarg1 is numeric: clarg1=offset, clarg2=length
                    dd if="$resolved" of="$cloopfile" bs=1 skip="$clarg1" count="$clarg2" >/dev/null 2>&1
                    ;;
            esac
        fi
        [ ! -f ${cloopfile} ] && echo "Loop file does not exist."
        return 1
    fi

    if cryptsetup isLuks ${cloopfile} >/dev/null 2>&1; then
        dopass=1
        # If keyfile exists, use it
        if [ -f "/cloop/${cloopkey}" ]; then
            if eval cryptsetup --key-file ${cloopkey} open ${cloopfile} ${cloopname} ${CSQUIET}; then
                dopass=0
            else
                echo -e "Invalid keyfile. Reverting to passphrase.\n"
            fi
        fi
        if [ ${dopass} -gt 0 ]; then
            echo "Enter a valid passphrase to access the ${cloopname} loop:"

            # Loop until valid password is provided.
            while ! eval cryptsetup open ${cloopfile} ${cloopname} ${CSQUIET}; do
                sleep 1;
            done
        fi
        [ -e "/dev/mapper/${cloopname}" ] && mount -r "/dev/mapper/${cloopname}" /cloop
    fi

    # Read devices to be unlocked and mounted
    if [ -n "${cryptdevices}" ]; then
        IFS=';' read -a devices <<EOF
$cryptdevices
EOF
    fi

    for device in "${devices[@]}"; do
        IFS=: read cryptdev cryptname header offset keysize options <<EOF
$device
EOF
        if [ -b "/dev/mapper/${cryptdev}" ]; then
            echo "Device ${cryptname} already exists."
            continue
        fi

        set -f
        OLDIFS="$IFS"; IFS=,
        for cryptopt in ${cryptoptions}; do
            case ${cryptopt} in
                allow-discards)
                    cryptargs="${cryptargs} --allow-discards"
                    ;;
                readonly)
                    cryptargs="${cryptargs} --readonly"
                    ;;
                *)
                    echo "Encryption option '${cryptopt}' not known." >&2
                    ;;
            esac
        done
        set +f
        IFS="$OLDIFS"
        unset OLDIFS

        if resolved=$(resolve_device "${cryptdev}" ${rootdelay}); then
            if cryptsetup --header="/cloop/${header}" ${resolved} >/dev/null 2>&1
                eval cryptsetup open --keyfile ${ckeyfile} --header ${header} --keyfile-offset ${offset} --keyfile-size=${keysize} ${cryptargs} ${cryptname} ${CSQUIET};
            fi
        fi
    done



    rm -f ${cloopfile} ${cloopkey}




    # mkdir -p /mnt
    # cryptsetup open /secret.img cryptkey
    # mount /dev/mapper/cryptkey /mnt
    # cryptsetup --header /mnt/nvme_header.bin --key-file=/mnt/crypto_keyfile.bin --keyfile-offset 512 open /dev/nvme0n1 cryptlvm
    # cryptsetup --header /mnt/sda_header.bin --key-file=/mnt/crypto_keyfile.bin --keyfile-size=512 open /dev/sda cryptext
    
    # umount /mnt
    # cryptsetup close cryptkey
} 
# vim: set ft=sh ts=4 sw=4 et:

